# üöÄ Complete Backend Development Notes
### From Basics to Advanced | Real-World Examples Included

---

# TABLE OF CONTENTS

1. [Foundation JavaScript & Async Nature of JS](#1-foundation-javascript--async-nature-of-js)
2. [Node.js and its Runtime](#2-nodejs-and-its-runtime)
3. [Databases ‚Äî NoSQL vs SQL](#3-databases--nosql-vs-sql)
4. [MongoDB and PostgreSQL Deep Dive](#4-mongodb-and-postgresql-deep-dive)
5. [TypeScript Beginner to Advanced](#5-typescript-beginner-to-advanced)
6. [Backend Fundamentals](#6-backend-fundamentals)
7. [Backend Communication Protocols](#7-backend-communication-protocols)
8. [Express.js Basic to Advanced](#8-expressjs-basic-to-advanced)
9. [ORMs (Prisma)](#9-orms-prisma)
10. [Middlewares, Routes, Status Codes, Global Catches](#10-middlewares-routes-status-codes-global-catches)
11. [Zod ‚Äî Schema Validation](#11-zod--schema-validation)
12. [MonoRepos & Turborepo](#12-monorepos--turborepo)
13. [Serverless Backends](#13-serverless-backends)
14. [OpenAPI Spec](#14-openapi-spec)
15. [Autogenerated Clients](#15-autogenerated-clients)
16. [Authentication using External Libraries](#16-authentication-using-external-libraries)
17. [Scaling Node.js & Performance Benchmarks](#17-scaling-nodejs--performance-benchmarks)
18. [Deploying npm Packages](#18-deploying-npm-packages)

---

# 1. Foundation JavaScript & Async Nature of JS

## 1.1 Why JavaScript for Backend?

JavaScript was originally a browser language. Node.js brought it to the server. Now the same language runs everywhere ‚Äî frontend, backend, scripts, CLI tools. This means:

- One language across your entire stack (less context switching)
- Massive npm ecosystem
- Non-blocking I/O makes it great for I/O-heavy apps (APIs, chat apps, streaming)

---

## 1.2 Core JavaScript Concepts

### Variables & Scope

```js
var x = 1;   // function-scoped, hoisted ‚Äî avoid using
let y = 2;   // block-scoped, not hoisted ‚Äî prefer this
const z = 3; // block-scoped, cannot reassign ‚Äî use for constants
```

**Real-World:** In Express route handlers, always use `const` for things like `db`, `router`, config objects. Use `let` only when you need to reassign.

```js
const express = require('express');
const router = express.Router();
```

### Hoisting

```js
console.log(greet()); // Works! ‚Äî function declarations are hoisted
console.log(sayHi);   // undefined ‚Äî var is hoisted but not initialized
console.log(sayBye);  // ReferenceError ‚Äî let/const not hoisted

function greet() { return "Hello"; }
var sayHi = () => "Hi";
let sayBye = () => "Bye";
```

### Closures

A closure is a function that "remembers" variables from its outer scope even after that scope has closed.

```js
function makeCounter() {
  let count = 0;
  return {
    increment: () => ++count,
    getCount: () => count
  };
}

const counter = makeCounter();
counter.increment(); // 1
counter.increment(); // 2
counter.getCount();  // 2
```

**Real-World:** Rate limiters in Express use closures to maintain state per IP:

```js
function createRateLimiter(maxRequests, windowMs) {
  const store = {}; // closed over by the returned middleware

  return (req, res, next) => {
    const ip = req.ip;
    const now = Date.now();

    if (!store[ip]) store[ip] = { count: 0, start: now };

    if (now - store[ip].start > windowMs) {
      store[ip] = { count: 0, start: now };
    }

    if (store[ip].count >= maxRequests) {
      return res.status(429).json({ error: 'Too many requests' });
    }

    store[ip].count++;
    next();
  };
}

app.use(createRateLimiter(100, 60 * 1000)); // 100 req/min
```

### Destructuring

```js
// Object destructuring
const { name, age, address: { city } } = user;

// Array destructuring
const [first, second, ...rest] = [1, 2, 3, 4, 5];

// With defaults
const { port = 3000, host = 'localhost' } = config;

// In function parameters ‚Äî very common in Express
app.get('/user/:id', async ({ params, query, body }, res) => {
  const { id } = params;
  const { page = 1, limit = 10 } = query;
});
```

### Spread & Rest

```js
// Spread ‚Äî expand an iterable
const merged = { ...defaultConfig, ...userConfig }; // userConfig overrides defaults

// Rest ‚Äî collect remaining args
function logRequest(method, url, ...middlewares) {
  console.log(`${method} ${url}`, middlewares.length, 'middlewares');
}

// Real-World: merging env config
const dbConfig = {
  ...defaultDb,
  host: process.env.DB_HOST,
  password: process.env.DB_PASS
};
```

---

## 1.3 Async Nature of JavaScript

### The Event Loop ‚Äî Most Important Concept

JavaScript is **single-threaded** ‚Äî it runs one piece of code at a time. But it can handle thousands of concurrent requests because of the **event loop**.

```
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ         Call Stack        ‚îÇ  ‚Üê Executes code
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ       Web APIs / libuv   ‚îÇ  ‚Üê Handles I/O, timers (in parallel, off-thread)
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ      Callback Queue       ‚îÇ  ‚Üê Waits here when ready
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ      Microtask Queue      ‚îÇ  ‚Üê Promises go here (higher priority)
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ        Event Loop         ‚îÇ  ‚Üê Moves callbacks to call stack when stack is empty
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Execution Order:**
1. Synchronous code runs first
2. Microtasks (Promises) run next ‚Äî before anything else
3. Macrotasks (setTimeout, setInterval, I/O callbacks) run last

```js
console.log('1 - sync');

setTimeout(() => console.log('2 - setTimeout'), 0);

Promise.resolve().then(() => console.log('3 - promise'));

console.log('4 - sync');

// Output: 1, 4, 3, 2
```

**Real-World Impact:** This is why Node.js can serve 10,000 concurrent requests with a single thread ‚Äî while waiting for a DB query to return, the event loop handles other requests.

---

### Callbacks (Old Way)

```js
// "Callback Hell" ‚Äî deeply nested, hard to read
fs.readFile('user.json', (err, data) => {
  if (err) throw err;
  JSON.parse(data);
  db.query(`SELECT * FROM users WHERE id = ${user.id}`, (err, result) => {
    if (err) throw err;
    sendEmail(result[0].email, (err) => {
      if (err) throw err;
      console.log('Done');
    });
  });
});
```

---

### Promises ‚Äî The Fix

A Promise represents a value that may be available now, in the future, or never. It has 3 states: **pending**, **fulfilled**, **rejected**.

```js
function fetchUser(id) {
  return new Promise((resolve, reject) => {
    db.query(`SELECT * FROM users WHERE id = $1`, [id], (err, result) => {
      if (err) reject(err);
      else resolve(result.rows[0]);
    });
  });
}

fetchUser(1)
  .then(user => sendEmail(user.email))
  .then(() => console.log('Email sent'))
  .catch(err => console.error('Error:', err))
  .finally(() => console.log('Done no matter what'));
```

**Promise Methods:**

```js
// Run multiple promises in parallel ‚Äî fails fast if any one fails
const [users, products] = await Promise.all([fetchUsers(), fetchProducts()]);

// Run all, get all results (success or failure)
const results = await Promise.allSettled([fetchA(), fetchB(), fetchC()]);
results.forEach(r => {
  if (r.status === 'fulfilled') console.log(r.value);
  else console.error(r.reason);
});

// First one to resolve wins
const fastest = await Promise.race([fetchFromCache(), fetchFromDB()]);

// First one to SUCCEED wins (ignores rejections until all fail)
const data = await Promise.any([fetchReplica1(), fetchReplica2()]);
```

**Real-World:** Fetching data from multiple sources simultaneously:

```js
// BAD ‚Äî sequential, takes 3x longer
const user = await fetchUser(id);
const orders = await fetchOrders(id);
const wishlist = await fetchWishlist(id);

// GOOD ‚Äî parallel, takes max(time) instead of sum(time)
const [user, orders, wishlist] = await Promise.all([
  fetchUser(id),
  fetchOrders(id),
  fetchWishlist(id)
]);
```

---

### async/await ‚Äî Syntactic Sugar over Promises

```js
// This is exactly the same as Promise chaining, just cleaner
async function getOrderSummary(userId) {
  try {
    const user = await db.findUser(userId);
    if (!user) throw new Error('User not found');

    const orders = await db.findOrders(userId);
    const total = orders.reduce((sum, o) => sum + o.amount, 0);

    return { user, orders, total };
  } catch (err) {
    console.error('Failed to get order summary:', err);
    throw err; // re-throw so caller can handle it
  }
}
```

**Real-World Express Route:**

```js
app.get('/dashboard/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const summary = await getOrderSummary(userId);
    res.json(summary);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});
```

---

### Common Async Mistakes

```js
// ‚ùå MISTAKE 1: Forgetting await ‚Äî function returns a Promise, not the value
const user = fetchUser(id); // user = Promise object, not user data!
console.log(user.name);     // undefined

// ‚úÖ FIX
const user = await fetchUser(id);

// ‚ùå MISTAKE 2: Not handling errors in async route handlers
app.get('/users', async (req, res) => {
  const users = await db.getUsers(); // If this throws, Express crashes!
  res.json(users);
});

// ‚úÖ FIX: Always wrap in try/catch or use an async wrapper
app.get('/users', async (req, res, next) => {
  try {
    const users = await db.getUsers();
    res.json(users);
  } catch (err) {
    next(err); // pass to global error handler
  }
});

// ‚ùå MISTAKE 3: Sequential awaits when parallel is possible
const a = await fetchA();
const b = await fetchB(); // waits for A even though B doesn't need A

// ‚úÖ FIX
const [a, b] = await Promise.all([fetchA(), fetchB()]);

// ‚ùå MISTAKE 4: Using await inside forEach ‚Äî doesn't work as expected!
orders.forEach(async (order) => {
  await processOrder(order); // These all run but forEach doesn't wait!
});
console.log('Done'); // Runs BEFORE orders are processed!

// ‚úÖ FIX: Use for...of
for (const order of orders) {
  await processOrder(order);
}
// Or process in parallel with Promise.all + map
await Promise.all(orders.map(order => processOrder(order)));
```

---

### Event Emitters

Node.js is built on events. Understanding this helps understand streams, HTTP, and many Node internals.

```js
const EventEmitter = require('events');

class PaymentProcessor extends EventEmitter {
  async processPayment(orderId, amount) {
    try {
      const result = await chargeCard(amount);
      this.emit('payment:success', { orderId, result });
    } catch (err) {
      this.emit('payment:failed', { orderId, err });
    }
  }
}

const processor = new PaymentProcessor();

processor.on('payment:success', ({ orderId }) => {
  sendConfirmationEmail(orderId);
  updateOrderStatus(orderId, 'paid');
  analytics.track('payment_success', { orderId });
});

processor.on('payment:failed', ({ orderId, err }) => {
  alertOpsTeam(err);
  updateOrderStatus(orderId, 'failed');
});

processor.processPayment('ORD-123', 4999);
```

---

# 2. Node.js and its Runtime

## 2.1 What is Node.js?

Node.js is a **JavaScript runtime** built on Chrome's V8 engine + **libuv** (a C library for async I/O).

- **V8**: Compiles JavaScript to machine code (JIT compilation)
- **libuv**: Handles file system, network, timers asynchronously using OS-level mechanisms (epoll on Linux, kqueue on macOS, IOCP on Windows)
- **Node APIs**: The bridge between JS and libuv (fs, net, http, etc.)

```
  Your Code (JS)
       ‚îÇ
  Node.js APIs (fs, http, net...)
       ‚îÇ
  V8 Engine (JS to machine code)      +      libuv (async I/O)
                                              ‚îÇ
                                         OS (Linux/macOS/Windows)
```

## 2.2 The Node.js Event Loop In Depth

```
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ           timers            ‚îÇ  ‚Üê setTimeout, setInterval callbacks
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ     pending callbacks       ‚îÇ  ‚Üê I/O callbacks deferred to next loop
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ       idle, prepare         ‚îÇ  ‚Üê Internal use
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ            poll             ‚îÇ  ‚Üê Retrieve new I/O events, execute I/O callbacks
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ            check            ‚îÇ  ‚Üê setImmediate callbacks
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ      close callbacks        ‚îÇ  ‚Üê socket.on('close', ...)
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Between each phase: process.nextTick() and Promise microtasks run
```

```js
setTimeout(() => console.log('setTimeout'), 0);
setImmediate(() => console.log('setImmediate'));
process.nextTick(() => console.log('nextTick'));
Promise.resolve().then(() => console.log('Promise'));

// Output: nextTick ‚Üí Promise ‚Üí setTimeout (or setImmediate, order varies) ‚Üí setImmediate
```

**process.nextTick** runs before any I/O, before Promises even. Use sparingly ‚Äî abusing it can starve the I/O queue.

---

## 2.3 Module System

### CommonJS (CJS) ‚Äî The Original

```js
// math.js
function add(a, b) { return a + b; }
module.exports = { add };
// or: module.exports = add; for single export

// app.js
const { add } = require('./math');
const fs = require('fs');    // built-in
const express = require('express'); // npm package
```

### ES Modules (ESM) ‚Äî The Modern Way

```js
// math.js
export function add(a, b) { return a + b; }
export default class Calculator { ... }

// app.js
import { add } from './math.js'; // .js extension required in Node ESM
import Calculator from './math.js';
import * as math from './math.js';
```

To use ESM in Node:
- Add `"type": "module"` to package.json, OR
- Use `.mjs` extension

**Key difference:** `require()` is synchronous. `import` is static and hoisted. ESM can do tree-shaking.

---

## 2.4 File System (fs module)

```js
const fs = require('fs');
const fsp = require('fs').promises; // Promise-based version

// Synchronous ‚Äî BLOCKS the event loop! Only ok for startup scripts
const config = JSON.parse(fs.readFileSync('./config.json', 'utf8'));

// Callback-based
fs.readFile('./data.json', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(JSON.parse(data));
});

// Promise-based (best for async code)
async function loadConfig() {
  const raw = await fsp.readFile('./config.json', 'utf8');
  return JSON.parse(raw);
}

// Writing files
await fsp.writeFile('./output.json', JSON.stringify(data, null, 2));
await fsp.appendFile('./logs/app.log', `${new Date().toISOString()} - ${message}\n`);

// Working with directories
await fsp.mkdir('./uploads', { recursive: true }); // recursive = no error if exists
const files = await fsp.readdir('./uploads');
await fsp.unlink('./temp/file.tmp'); // delete file
```

**Real-World:** File upload handler saving files to disk:

```js
const path = require('path');
const fsp = require('fs').promises;

async function saveUpload(buffer, originalName, userId) {
  const uploadDir = path.join('./uploads', userId.toString());
  await fsp.mkdir(uploadDir, { recursive: true });

  const ext = path.extname(originalName);
  const filename = `${Date.now()}-${Math.random().toString(36).slice(2)}${ext}`;
  const filepath = path.join(uploadDir, filename);

  await fsp.writeFile(filepath, buffer);
  return filepath;
}
```

---

## 2.5 Streams

Streams are one of Node's superpowers. Instead of loading an entire file into memory, you process data **chunk by chunk**.

**Types:**
- **Readable** ‚Äî source of data (fs.createReadStream, http request)
- **Writable** ‚Äî destination (fs.createWriteStream, http response)
- **Duplex** ‚Äî both (TCP socket)
- **Transform** ‚Äî duplex that transforms data (zlib compression)

```js
const fs = require('fs');
const zlib = require('zlib');

// ‚ùå BAD ‚Äî loads entire 2GB file into memory
const data = fs.readFileSync('huge-file.csv');
res.send(data);

// ‚úÖ GOOD ‚Äî streams file to client, uses constant memory
const readable = fs.createReadStream('huge-file.csv');
readable.pipe(res);

// Real-World: Stream + compress + stream to client
app.get('/download/:file', (req, res) => {
  res.setHeader('Content-Encoding', 'gzip');
  res.setHeader('Content-Type', 'text/csv');

  fs.createReadStream(`./exports/${req.params.file}`)
    .pipe(zlib.createGzip())
    .pipe(res);
});
```

**Transform Stream ‚Äî CSV parser:**

```js
const { Transform } = require('stream');

const csvParser = new Transform({
  objectMode: true,
  transform(chunk, encoding, callback) {
    const lines = chunk.toString().split('\n');
    lines.forEach(line => {
      if (line.trim()) {
        const [name, email, age] = line.split(',');
        this.push({ name, email, age: Number(age) });
      }
    });
    callback();
  }
});

fs.createReadStream('users.csv')
  .pipe(csvParser)
  .on('data', user => db.insertUser(user))
  .on('end', () => console.log('Import complete'));
```

---

## 2.6 HTTP Module (Low Level)

Express is built on top of this. Good to understand what's underneath.

```js
const http = require('http');

const server = http.createServer((req, res) => {
  // req = IncomingMessage (Readable stream)
  // res = ServerResponse (Writable stream)

  const { method, url, headers } = req;

  // Read request body
  let body = '';
  req.on('data', chunk => body += chunk);
  req.on('end', () => {
    const parsed = JSON.parse(body || '{}');

    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ received: parsed }));
  });
});

server.listen(3000, () => console.log('Server running on port 3000'));
```

---

## 2.7 Environment Variables

Never hardcode secrets. Use environment variables.

```js
// .env file (never commit this!)
DATABASE_URL=postgresql://user:password@localhost/mydb
JWT_SECRET=super-secret-key-here
PORT=3000
NODE_ENV=development

// Load with dotenv
require('dotenv').config(); // Call this at the very top of your app entry point

const dbUrl = process.env.DATABASE_URL;
const port = parseInt(process.env.PORT) || 3000;
const isProd = process.env.NODE_ENV === 'production';
```

**Best Practice ‚Äî config.js:**

```js
// config.js ‚Äî centralize all env vars, validate early
const config = {
  port: parseInt(process.env.PORT) || 3000,
  db: {
    url: process.env.DATABASE_URL,
    poolSize: parseInt(process.env.DB_POOL_SIZE) || 10
  },
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRES_IN || '7d'
  },
  redis: {
    url: process.env.REDIS_URL
  }
};

// Validate required vars on startup
const required = ['DATABASE_URL', 'JWT_SECRET'];
required.forEach(key => {
  if (!process.env[key]) {
    throw new Error(`Missing required environment variable: ${key}`);
  }
});

module.exports = config;
```

---

# 3. Databases ‚Äî NoSQL vs SQL

## 3.1 What is a Database?

A database is an organized collection of structured data, managed by a Database Management System (DBMS). They allow you to:
- Store data persistently (survives server restart)
- Query data efficiently
- Handle concurrent access safely
- Ensure data integrity

---

## 3.2 SQL (Relational Databases)

Data stored in **tables** with **rows** and **columns**. Tables relate to each other via **foreign keys**.

**Examples:** PostgreSQL, MySQL, SQLite, Microsoft SQL Server

**When to use SQL:**
- You have structured, predictable data
- Data has complex relationships (users ‚Üí orders ‚Üí products)
- You need ACID guarantees (financial data, inventory)
- You need complex queries (joins, aggregations, reporting)

```sql
-- Users table
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(100) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Orders table (relates to users)
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INT REFERENCES users(id) ON DELETE CASCADE,
  total DECIMAL(10, 2) NOT NULL,
  status VARCHAR(50) DEFAULT 'pending',
  created_at TIMESTAMP DEFAULT NOW()
);

-- Query: Get all users with their order count and total spend
SELECT
  u.name,
  u.email,
  COUNT(o.id) AS order_count,
  SUM(o.total) AS total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id
ORDER BY total_spent DESC;
```

---

## 3.3 NoSQL (Non-Relational Databases)

Data stored in flexible formats ‚Äî documents, key-value pairs, graphs, etc.

**Examples:**
- **Document:** MongoDB, CouchDB ‚Äî JSON-like documents
- **Key-Value:** Redis, DynamoDB ‚Äî fast lookups by key
- **Graph:** Neo4j ‚Äî relationships between data
- **Time-Series:** InfluxDB, TimescaleDB ‚Äî time-stamped data

**When to use NoSQL:**
- Schema is flexible or frequently changing
- You need horizontal scaling across many servers
- High write throughput (social media feeds, IoT data)
- Hierarchical/nested data that doesn't fit rows/columns well
- Caching (Redis)

---

## 3.4 ACID Properties (SQL guarantee)

**A ‚Äî Atomicity:** All operations in a transaction succeed or all fail. No partial updates.

```sql
BEGIN;
  UPDATE accounts SET balance = balance - 500 WHERE id = 1; -- Debit
  UPDATE accounts SET balance = balance + 500 WHERE id = 2; -- Credit
  -- If second UPDATE fails, first is rolled back too
COMMIT;
```

**C ‚Äî Consistency:** Data always moves from one valid state to another. Constraints are enforced.

**I ‚Äî Isolation:** Concurrent transactions don't interfere with each other.

**D ‚Äî Durability:** Once committed, data survives crashes (written to disk).

---

## 3.5 CAP Theorem

In a distributed system, you can only guarantee 2 of 3:

- **C ‚Äî Consistency:** Every read gets the most recent write
- **A ‚Äî Availability:** Every request gets a response (not guaranteed to be latest)
- **P ‚Äî Partition Tolerance:** System keeps working even if network splits

```
        Consistency
           /\
          /  \
         /    \
        /  CA  \      ‚Üê Traditional SQL (single server)
       /--------\
      / CP  | AP \
     /      |     \
    MongoDB Redis  Cassandra
   (CP)    (CP)    (AP)
```

**Real-World Decision:**
- **Banking app:** Choose CP ‚Äî you'd rather be down than show wrong balance
- **Social media feed:** Choose AP ‚Äî it's ok to see slightly stale data, better to be available
- **E-commerce cart:** Choose AP ‚Äî let the cart work, reconcile inventory on checkout

---

# 4. MongoDB and PostgreSQL Deep Dive

## 4.1 MongoDB Deep Dive

### Core Concepts

```
Database ‚Üí Collection ‚Üí Document
  myapp  ‚Üí   users   ‚Üí { _id: ..., name: "Alice", email: "alice@..." }
```

MongoDB stores documents as **BSON** (Binary JSON) ‚Äî supports more types than regular JSON (Date, ObjectId, Binary, etc.)

### CRUD Operations

```js
const { MongoClient, ObjectId } = require('mongodb');

const client = new MongoClient(process.env.MONGO_URL);
await client.connect();

const db = client.db('myapp');
const users = db.collection('users');

// INSERT
const result = await users.insertOne({
  name: 'Alice',
  email: 'alice@example.com',
  role: 'user',
  createdAt: new Date(),
  profile: {
    bio: 'Software engineer',
    avatar: 'https://...'
  },
  tags: ['developer', 'node']
});
console.log(result.insertedId); // ObjectId

// Bulk insert
await users.insertMany([
  { name: 'Bob', email: 'bob@example.com' },
  { name: 'Charlie', email: 'charlie@example.com' }
]);

// FIND
const alice = await users.findOne({ email: 'alice@example.com' });

// Find with projection (only get specific fields)
const allUsers = await users
  .find({ role: 'user' }, { projection: { name: 1, email: 1, _id: 0 } })
  .sort({ createdAt: -1 })
  .skip(0)
  .limit(10)
  .toArray();

// Complex queries
const results = await users.find({
  role: { $in: ['admin', 'moderator'] },      // role is admin OR moderator
  createdAt: { $gte: new Date('2024-01-01') }, // created after Jan 1 2024
  tags: { $all: ['developer', 'node'] },       // has both tags
  'profile.bio': { $exists: true },            // has bio field
  age: { $gte: 18, $lte: 65 }                 // age between 18-65
}).toArray();

// UPDATE
await users.updateOne(
  { _id: new ObjectId(userId) },
  {
    $set: { name: 'Alice Smith', updatedAt: new Date() },
    $push: { tags: 'fullstack' },    // add to array
    $inc: { loginCount: 1 }          // increment number
  }
);

// Upsert ‚Äî insert if not exists, update if exists
await users.updateOne(
  { email: 'newuser@example.com' },
  { $set: { name: 'New User', role: 'user' } },
  { upsert: true }
);

// DELETE
await users.deleteOne({ _id: new ObjectId(userId) });
await users.deleteMany({ role: 'banned', createdAt: { $lt: oneYearAgo } });
```

### Schema Design ‚Äî Embed vs Reference

**Embed** when:
- Data is always accessed together
- Data doesn't need to be shared
- Array has bounded size

```js
// Embedded ‚Äî user profile always comes with user
{
  _id: ObjectId("..."),
  name: "Alice",
  email: "alice@example.com",
  profile: {              // embedded document
    bio: "Dev",
    avatar: "https://...",
    location: "NYC"
  },
  addresses: [            // embedded array (bounded ‚Äî users have few addresses)
    { type: "home", street: "123 Main St", city: "NYC" },
    { type: "work", street: "456 Park Ave", city: "NYC" }
  ]
}
```

**Reference** when:
- Data is frequently accessed independently
- Many-to-many relationships
- Array would grow unboundedly

```js
// User document
{ _id: ObjectId("user1"), name: "Alice" }

// Order documents (reference user)
{ _id: ObjectId("ord1"), userId: ObjectId("user1"), total: 99.99 }
{ _id: ObjectId("ord2"), userId: ObjectId("user1"), total: 149.99 }
// Orders can be queried independently, don't need user data each time
```

### Indexes

Without indexes, MongoDB scans every document (**collection scan**). Indexes make queries fast.

```js
// Single field index
await users.createIndex({ email: 1 });  // ascending
await users.createIndex({ createdAt: -1 }); // descending (useful for "latest first" queries)

// Compound index ‚Äî order matters!
// Supports queries on (status), (status, createdAt), but NOT (createdAt) alone
await orders.createIndex({ status: 1, createdAt: -1 });

// Unique index
await users.createIndex({ email: 1 }, { unique: true });

// Text index ‚Äî for full text search
await products.createIndex({ name: 'text', description: 'text' });
await products.find({ $text: { $search: "wireless headphones" } });

// Sparse index ‚Äî only indexes docs that have the field
await users.createIndex({ googleId: 1 }, { unique: true, sparse: true });

// TTL index ‚Äî auto-delete documents after expiry
await sessions.createIndex({ createdAt: 1 }, { expireAfterSeconds: 86400 }); // 24h
```

### Aggregation Pipeline

The aggregation pipeline transforms documents through a series of stages.

```js
// Real-World: E-commerce sales report
const report = await orders.aggregate([
  // Stage 1: Filter orders from this month
  { $match: {
    createdAt: { $gte: startOfMonth, $lte: endOfMonth },
    status: 'completed'
  }},

  // Stage 2: Join with products collection
  { $lookup: {
    from: 'products',
    localField: 'productId',
    foreignField: '_id',
    as: 'product'
  }},

  { $unwind: '$product' },

  // Stage 3: Group by category
  { $group: {
    _id: '$product.category',
    totalRevenue: { $sum: { $multiply: ['$quantity', '$product.price'] } },
    orderCount: { $sum: 1 },
    avgOrderValue: { $avg: '$total' }
  }},

  // Stage 4: Sort by revenue descending
  { $sort: { totalRevenue: -1 } },

  // Stage 5: Add computed field
  { $addFields: {
    revenueFormatted: {
      $concat: ['$', { $toString: { $round: ['$totalRevenue', 2] } }]
    }
  }}
]).toArray();
```

---

## 4.2 PostgreSQL Deep Dive

### Setup & Connection

```js
const { Pool } = require('pg');

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20,            // max connections in pool
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

// Basic query
const { rows } = await pool.query('SELECT * FROM users WHERE id = $1', [userId]);

// Transaction
const client = await pool.connect();
try {
  await client.query('BEGIN');
  await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, fromId]);
  await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, toId]);
  await client.query('COMMIT');
} catch (err) {
  await client.query('ROLLBACK');
  throw err;
} finally {
  client.release(); // ALWAYS release back to pool
}
```

### Schema Design

```sql
-- Users table with proper constraints
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),  -- UUID better than serial for distributed systems
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255),  -- Never store plaintext passwords
  name VARCHAR(100) NOT NULL,
  role VARCHAR(50) DEFAULT 'user' CHECK (role IN ('user', 'admin', 'moderator')),
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),  -- TIMESTAMPTZ = timestamp with timezone
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Auto-update updated_at trigger
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER users_updated_at
  BEFORE UPDATE ON users
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- Products
CREATE TABLE products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),
  stock INT NOT NULL DEFAULT 0 CHECK (stock >= 0),
  category VARCHAR(100),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Orders
CREATE TABLE orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE RESTRICT,  -- don't delete user with orders
  status VARCHAR(50) DEFAULT 'pending'
    CHECK (status IN ('pending', 'confirmed', 'shipped', 'delivered', 'cancelled')),
  total DECIMAL(10, 2) NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Order items (many-to-many between orders and products)
CREATE TABLE order_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  product_id UUID NOT NULL REFERENCES products(id) ON DELETE RESTRICT,
  quantity INT NOT NULL CHECK (quantity > 0),
  unit_price DECIMAL(10, 2) NOT NULL,  -- snapshot price at time of order
  UNIQUE(order_id, product_id)
);
```

### Joins

```sql
-- INNER JOIN: Only rows that match in both tables
SELECT u.name, o.id, o.total, o.status
FROM users u
INNER JOIN orders o ON u.id = o.user_id
WHERE u.email = 'alice@example.com';

-- LEFT JOIN: All users, even those with no orders
SELECT u.name, COUNT(o.id) as order_count, COALESCE(SUM(o.total), 0) as total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name
ORDER BY total_spent DESC;

-- Complex join with multiple tables
SELECT
  u.name AS customer,
  o.id AS order_id,
  o.created_at AS order_date,
  p.name AS product,
  oi.quantity,
  oi.unit_price,
  (oi.quantity * oi.unit_price) AS line_total
FROM orders o
JOIN users u ON o.user_id = u.id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE o.status = 'delivered'
  AND o.created_at >= NOW() - INTERVAL '30 days'
ORDER BY o.created_at DESC;
```

### Advanced PostgreSQL

```sql
-- Window functions ‚Äî powerful for analytics
SELECT
  user_id,
  total,
  created_at,
  ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at) AS order_number,
  SUM(total) OVER (PARTITION BY user_id ORDER BY created_at) AS running_total,
  AVG(total) OVER (PARTITION BY user_id) AS avg_order_value
FROM orders
WHERE status = 'completed';

-- CTE (Common Table Expression) ‚Äî readable complex queries
WITH monthly_revenue AS (
  SELECT
    DATE_TRUNC('month', created_at) AS month,
    SUM(total) AS revenue
  FROM orders
  WHERE status = 'completed'
  GROUP BY month
),
growth AS (
  SELECT
    month,
    revenue,
    LAG(revenue) OVER (ORDER BY month) AS prev_month_revenue,
    (revenue - LAG(revenue) OVER (ORDER BY month)) / LAG(revenue) OVER (ORDER BY month) * 100 AS growth_pct
  FROM monthly_revenue
)
SELECT
  TO_CHAR(month, 'Month YYYY') AS period,
  revenue,
  ROUND(growth_pct, 2) AS growth_percentage
FROM growth
ORDER BY month;

-- JSON in PostgreSQL ‚Äî best of both worlds
CREATE TABLE products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255),
  metadata JSONB  -- JSONB = binary JSON, indexed and queryable
);

-- Query JSONB
SELECT * FROM products
WHERE metadata->>'color' = 'red'
  AND (metadata->>'weight')::numeric < 1.5;

-- Index a JSONB field
CREATE INDEX ON products ((metadata->>'category'));

-- Full text search
ALTER TABLE products ADD COLUMN search_vector tsvector;
UPDATE products SET search_vector = to_tsvector('english', name || ' ' || description);
CREATE INDEX ON products USING GIN (search_vector);

SELECT * FROM products
WHERE search_vector @@ plainto_tsquery('english', 'wireless headphones')
ORDER BY ts_rank(search_vector, plainto_tsquery('english', 'wireless headphones')) DESC;
```

### Indexes in PostgreSQL

```sql
-- B-tree (default) ‚Äî good for equality and range queries
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status_created ON orders(status, created_at DESC);

-- Partial index ‚Äî index only a subset of rows
CREATE INDEX idx_active_users ON users(email) WHERE is_active = true;
-- Queries filtered by is_active = true AND email are much faster

-- EXPLAIN ANALYZE ‚Äî understand query performance
EXPLAIN ANALYZE
SELECT * FROM orders WHERE user_id = 'some-uuid' AND status = 'completed';
-- Look for: Seq Scan (bad for large tables), Index Scan (good), Bitmap Index Scan (good)
```

---

# 5. TypeScript Beginner to Advanced

## 5.1 Why TypeScript?

TypeScript is a **typed superset of JavaScript** that compiles to plain JavaScript. It catches bugs at compile time rather than runtime.

```js
// JavaScript ‚Äî bug discovered in production
function calculateDiscount(price, discountPercent) {
  return price - (price * discountPercent / 100);
}
calculateDiscount("100", 20); // "100" - 20 = "10020" ‚Äî string concatenation!

// TypeScript ‚Äî caught immediately
function calculateDiscount(price: number, discountPercent: number): number {
  return price - (price * discountPercent / 100);
}
calculateDiscount("100", 20); // ‚ùå Error: Argument of type 'string' not assignable to 'number'
```

## 5.2 Basic Types

```ts
// Primitives
let name: string = "Alice";
let age: number = 30;
let isActive: boolean = true;
let data: null = null;
let value: undefined = undefined;

// Arrays
let nums: number[] = [1, 2, 3];
let strings: Array<string> = ["a", "b"];

// Tuples ‚Äî fixed-length arrays with known types
let point: [number, number] = [10, 20];
let entry: [string, number] = ["Alice", 30]; // CSV row

// any ‚Äî opt out of type checking (avoid!)
let x: any = "hello";
x = 42; // ok with any, but you lose all type safety

// unknown ‚Äî safer alternative to any
let input: unknown = getUserInput();
if (typeof input === 'string') {
  console.log(input.toUpperCase()); // safe ‚Äî narrowed to string
}

// never ‚Äî values that never exist (exhaustive checks, infinite loops)
function throwError(message: string): never {
  throw new Error(message);
}

// void ‚Äî function returns nothing meaningful
function logMessage(msg: string): void {
  console.log(msg);
}
```

## 5.3 Interfaces & Types

```ts
// Interface ‚Äî describes the shape of an object
interface User {
  id: string;
  name: string;
  email: string;
  role: 'user' | 'admin';   // literal union type
  age?: number;              // optional field
  readonly createdAt: Date;  // can't be changed after creation
}

// Type alias ‚Äî similar to interface, more flexible
type Status = 'pending' | 'active' | 'inactive';
type ID = string | number;
type Callback<T> = (error: Error | null, data: T) => void;

// Interface extension
interface AdminUser extends User {
  permissions: string[];
  lastLogin: Date;
}

// Type intersection (equivalent to extends)
type AdminUser = User & {
  permissions: string[];
  lastLogin: Date;
};

// Interface vs Type ‚Äî when to use which?
// Interface: Use for objects/classes that may be extended (more OOP-friendly)
// Type: Use for unions, intersections, primitives, tuples, computed types
```

## 5.4 Generics

Generics allow you to write reusable code that works with different types.

```ts
// Without generics ‚Äî need separate functions for each type
function getFirstNumber(arr: number[]): number { return arr[0]; }
function getFirstString(arr: string[]): string { return arr[0]; }

// With generics ‚Äî one function for any type
function getFirst<T>(arr: T[]): T {
  return arr[0];
}
const num = getFirst([1, 2, 3]);       // T = number, returns number
const str = getFirst(["a", "b", "c"]); // T = string, returns string

// Generic interface ‚Äî API response wrapper
interface ApiResponse<T> {
  data: T;
  success: boolean;
  message: string;
  timestamp: Date;
}

// Usage
type UserResponse = ApiResponse<User>;
type UsersResponse = ApiResponse<User[]>;
type PaginatedUsers = ApiResponse<{ users: User[]; total: number; page: number; }>;

// Generic function with constraints
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}
const user: User = { id: '1', name: 'Alice', email: 'a@b.com', role: 'user', createdAt: new Date() };
const name = getProperty(user, 'name');  // string
const id = getProperty(user, 'id');      // string
// getProperty(user, 'invalid');         // ‚ùå Error: not a key of User

// Generic class
class Repository<T extends { id: string }> {
  private items: T[] = [];

  add(item: T): void {
    this.items.push(item);
  }

  findById(id: string): T | undefined {
    return this.items.find(item => item.id === id);
  }

  getAll(): T[] {
    return [...this.items];
  }
}

const userRepo = new Repository<User>();
const productRepo = new Repository<Product>();
```

## 5.5 Utility Types

TypeScript includes built-in utility types that manipulate existing types.

```ts
interface User {
  id: string;
  name: string;
  email: string;
  password: string;
  role: 'user' | 'admin';
  createdAt: Date;
}

// Partial<T> ‚Äî makes all fields optional (for PATCH requests)
type UpdateUserDto = Partial<User>;
// { id?: string; name?: string; email?: string; ... }

// Required<T> ‚Äî makes all fields required
type FullUser = Required<Partial<User>>;

// Pick<T, K> ‚Äî select only specific fields
type PublicUser = Pick<User, 'id' | 'name' | 'role'>;
// { id: string; name: string; role: 'user' | 'admin' }

// Omit<T, K> ‚Äî exclude specific fields
type CreateUserDto = Omit<User, 'id' | 'createdAt'>;
// { name: string; email: string; password: string; role: 'user' | 'admin' }

type UserWithoutPassword = Omit<User, 'password'>;
// Safe to send to frontend

// Record<K, V> ‚Äî object with keys K and values V
type RolePermissions = Record<'user' | 'admin', string[]>;
const permissions: RolePermissions = {
  user: ['read'],
  admin: ['read', 'write', 'delete']
};

// Readonly<T> ‚Äî prevents modification
type ImmutableUser = Readonly<User>;
const user: ImmutableUser = { ... };
user.name = "Bob"; // ‚ùå Error: Cannot assign to 'name' because it is read only

// ReturnType<T> ‚Äî extract return type of a function
async function fetchUser(id: string): Promise<User> { ... }
type FetchUserReturn = Awaited<ReturnType<typeof fetchUser>>; // User

// Parameters<T> ‚Äî extract parameter types
type FetchUserParams = Parameters<typeof fetchUser>; // [string]
```

## 5.6 TypeScript with Express

```ts
import express, { Request, Response, NextFunction } from 'express';

// Extend Request type with custom properties
declare global {
  namespace Express {
    interface Request {
      user?: User;          // added by auth middleware
      requestId?: string;   // added by logging middleware
    }
  }
}

// Typed route handlers
interface CreateUserBody {
  name: string;
  email: string;
  password: string;
}

interface UserParams {
  id: string;
}

interface UserQuery {
  page?: string;
  limit?: string;
  search?: string;
}

// Fully typed route
app.post('/users',
  async (req: Request<{}, {}, CreateUserBody>, res: Response<ApiResponse<User>>) => {
    const { name, email, password } = req.body;
    const user = await userService.create({ name, email, password });
    res.status(201).json({ data: user, success: true, message: 'User created', timestamp: new Date() });
  }
);

app.get('/users/:id',
  async (req: Request<UserParams, {}, {}, UserQuery>, res: Response) => {
    const user = await userService.findById(req.params.id);
    res.json(user);
  }
);
```

## 5.7 TypeScript Configuration

```json
// tsconfig.json ‚Äî recommended for Node.js backend
{
  "compilerOptions": {
    "target": "ES2020",          // Compile to this JS version
    "module": "commonjs",        // CommonJS for Node.js
    "lib": ["ES2020"],           // Type definitions to include
    "outDir": "./dist",          // Output directory
    "rootDir": "./src",          // Source directory
    "strict": true,              // Enable all strict checks ‚Äî ALWAYS do this
    "esModuleInterop": true,     // Better default import support
    "skipLibCheck": true,        // Skip type checking of .d.ts files
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,   // Allow importing JSON
    "declaration": true,         // Generate .d.ts files (for packages)
    "sourceMap": true,           // Generate source maps (for debugging)
    "noUncheckedIndexedAccess": true,  // arr[0] returns T | undefined (safer)
    "noImplicitReturns": true,   // Functions must return in all branches
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

---

# 6. Backend Fundamentals

## 6.1 How the Web Works

```
  User Types URL         Browser resolves      Browser sends HTTP
  example.com/users  ‚Üí  IP (via DNS)       ‚Üí  request to server
                         93.184.216.34

  Server processes       Server sends           Browser renders
  the request        ‚Üê  HTTP response      ‚Üê   (HTML, JSON, etc.)
```

### DNS (Domain Name System)

```
  example.com
       ‚îÇ
  Root nameservers (.com)
       ‚îÇ
  TLD nameservers (example.com)
       ‚îÇ
  Authoritative nameserver (returns IP: 93.184.216.34)
```

This lookup is cached at multiple levels (browser, OS, ISP) ‚Äî that's why DNS changes take time to propagate.

---

## 6.2 HTTP ‚Äî The Protocol of the Web

HTTP is a **stateless** request-response protocol. Each request is independent.

### HTTP Methods (Verbs)

| Method | Purpose | Body? | Idempotent? |
|--------|---------|-------|-------------|
| GET | Retrieve data | No | Yes |
| POST | Create new resource | Yes | No |
| PUT | Replace entire resource | Yes | Yes |
| PATCH | Partially update resource | Yes | No |
| DELETE | Delete resource | Optional | Yes |
| HEAD | Like GET but no body | No | Yes |
| OPTIONS | What methods are supported? | No | Yes |

**Idempotent** = making the same request multiple times has the same effect as making it once.

### HTTP Status Codes

```
1xx ‚Äî Informational
  100 Continue
  101 Switching Protocols (WebSocket upgrade)

2xx ‚Äî Success
  200 OK ‚Äî Standard success
  201 Created ‚Äî Resource was created
  204 No Content ‚Äî Success but nothing to return (DELETE)

3xx ‚Äî Redirection
  301 Moved Permanently ‚Äî permanent redirect (update bookmarks)
  302 Found ‚Äî temporary redirect
  304 Not Modified ‚Äî cached version is still valid

4xx ‚Äî Client Errors
  400 Bad Request ‚Äî malformed request, validation error
  401 Unauthorized ‚Äî not authenticated (not logged in)
  403 Forbidden ‚Äî authenticated but not authorized (no permission)
  404 Not Found
  409 Conflict ‚Äî resource already exists (duplicate email)
  422 Unprocessable Entity ‚Äî validation failed
  429 Too Many Requests ‚Äî rate limited

5xx ‚Äî Server Errors
  500 Internal Server Error ‚Äî unexpected server error
  502 Bad Gateway ‚Äî upstream server error
  503 Service Unavailable ‚Äî server is down/overloaded
  504 Gateway Timeout ‚Äî upstream server took too long
```

### HTTP Headers

```
Request Headers:
  Content-Type: application/json        ‚Äî What format is the body?
  Authorization: Bearer eyJhbGci...     ‚Äî Authentication token
  Accept: application/json              ‚Äî What format do I want back?
  Cookie: sessionId=abc123              ‚Äî Cookies sent to server

Response Headers:
  Content-Type: application/json        ‚Äî What format is the body?
  Set-Cookie: sessionId=abc123; HttpOnly; Secure
  Cache-Control: max-age=3600           ‚Äî Cache for 1 hour
  X-Rate-Limit-Remaining: 95           ‚Äî Custom header
  CORS headers:
    Access-Control-Allow-Origin: https://myapp.com
    Access-Control-Allow-Methods: GET, POST, PUT, DELETE
```

## 6.3 REST API Design

REST (Representational State Transfer) is an architectural style, not a standard.

**RESTful Resource Design:**

```
Resources are nouns, actions are HTTP methods

Users:
  GET    /users           ‚Äî list all users
  POST   /users           ‚Äî create a user
  GET    /users/:id       ‚Äî get a specific user
  PUT    /users/:id       ‚Äî replace a user
  PATCH  /users/:id       ‚Äî update a user partially
  DELETE /users/:id       ‚Äî delete a user

Nested resources:
  GET    /users/:id/orders     ‚Äî orders for a specific user
  POST   /users/:id/orders     ‚Äî create order for a user
  GET    /users/:id/orders/:orderId ‚Äî specific order for a user

Actions (when REST doesn't fit):
  POST /users/:id/activate    ‚Äî activate a user (not a resource)
  POST /orders/:id/cancel     ‚Äî cancel an order
  POST /payments/:id/refund   ‚Äî refund a payment
```

**Real-World API Response Structure:**

```json
// Success response
{
  "success": true,
  "data": {
    "id": "usr_123",
    "name": "Alice Smith",
    "email": "alice@example.com"
  },
  "message": "User retrieved successfully"
}

// Paginated list response
{
  "success": true,
  "data": [...],
  "pagination": {
    "page": 1,
    "limit": 10,
    "total": 150,
    "totalPages": 15,
    "hasNext": true,
    "hasPrev": false
  }
}

// Error response
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": [
      { "field": "email", "message": "Invalid email format" },
      { "field": "password", "message": "Must be at least 8 characters" }
    ]
  }
}
```

---

# 7. Backend Communication Protocols

## 7.1 HTTP/1.1 vs HTTP/2 vs HTTP/3

### HTTP/1.1

- One request per TCP connection (HEAD-OF-LINE BLOCKING)
- Browsers open 6 connections per domain to work around this
- Text-based protocol

### HTTP/2

- **Multiplexing** ‚Äî multiple requests over a single connection simultaneously
- **Header compression** ‚Äî HPACK reduces overhead
- **Server push** ‚Äî server can send resources before client asks
- Binary protocol ‚Äî more efficient
- Requires HTTPS

```js
// Enable HTTP/2 in Node.js
const http2 = require('http2');
const fs = require('fs');

const server = http2.createSecureServer({
  key: fs.readFileSync('./server.key'),
  cert: fs.readFileSync('./server.cert')
});

server.on('stream', (stream, headers) => {
  stream.respond({ ':status': 200, 'content-type': 'application/json' });
  stream.end(JSON.stringify({ hello: 'world' }));
});
```

### HTTP/3

- Built on **QUIC** protocol (UDP-based, not TCP)
- No TCP head-of-line blocking ‚Äî each stream is independent
- Faster connection setup (0-RTT resumption)
- Better for mobile (handles network switching)

---

## 7.2 WebSockets

WebSockets provide **bidirectional, real-time communication** over a single persistent connection.

```
HTTP:  Client ‚Üí Request ‚Üí Server ‚Üí Response ‚Üí Connection closed
WS:    Client ‚ü∫ Server (persistent, bidirectional, low latency)
```

**Use cases:** Chat apps, live notifications, collaborative editing, live dashboards, multiplayer games.

```js
// Server with ws library
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

// Store connected clients with their metadata
const clients = new Map();

wss.on('connection', (ws, req) => {
  const userId = getUserIdFromToken(req.headers.authorization);
  clients.set(userId, ws);

  console.log(`User ${userId} connected. Total: ${clients.size}`);

  ws.on('message', (raw) => {
    const message = JSON.parse(raw);

    if (message.type === 'chat') {
      // Broadcast to all clients in the same room
      const roomClients = getRoomClients(message.roomId);
      roomClients.forEach(clientWs => {
        if (clientWs.readyState === WebSocket.OPEN) {
          clientWs.send(JSON.stringify({
            type: 'chat',
            from: userId,
            text: message.text,
            timestamp: new Date().toISOString()
          }));
        }
      });
    }

    if (message.type === 'typing') {
      // Notify others in room
      broadcastToRoom(message.roomId, userId, { type: 'typing', userId });
    }
  });

  ws.on('close', () => {
    clients.delete(userId);
    console.log(`User ${userId} disconnected`);
  });

  ws.on('error', (err) => {
    console.error(`WebSocket error for user ${userId}:`, err);
    clients.delete(userId);
  });
});

// Client (browser)
const ws = new WebSocket('wss://api.myapp.com/ws', {
  headers: { Authorization: `Bearer ${token}` }
});

ws.onopen = () => {
  ws.send(JSON.stringify({ type: 'join', roomId: 'room-123' }));
};

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  renderMessage(data);
};

ws.onerror = (err) => reconnect();
ws.onclose = () => reconnect();
```

---

## 7.3 Server-Sent Events (SSE)

SSE is **one-way streaming** from server to client. Simpler than WebSockets for push notifications.

```js
// Server
app.get('/notifications', (req, res) => {
  const userId = req.user.id;

  // Set SSE headers
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
    'Access-Control-Allow-Origin': '*'
  });

  // Send events
  const sendEvent = (data) => {
    res.write(`data: ${JSON.stringify(data)}\n\n`);
  };

  // Send a ping every 30s to keep connection alive
  const heartbeat = setInterval(() => {
    res.write(': heartbeat\n\n');
  }, 30000);

  // Subscribe to user events (from Redis, EventEmitter, etc.)
  const unsubscribe = pubsub.subscribe(`user:${userId}`, (event) => {
    sendEvent(event);
  });

  // Cleanup on disconnect
  req.on('close', () => {
    clearInterval(heartbeat);
    unsubscribe();
  });
});

// Client
const source = new EventSource('/notifications', {
  headers: { Authorization: `Bearer ${token}` }
});

source.onmessage = (event) => {
  const notification = JSON.parse(event.data);
  showNotification(notification);
};

source.onerror = () => {
  // SSE auto-reconnects by default!
  console.log('Reconnecting...');
};
```

---

## 7.4 Long Polling

A workaround for real-time without WebSockets. Client makes a request and the server holds it open until data is available or a timeout occurs.

```js
// Server
app.get('/poll', async (req, res) => {
  const { lastEventId = '0' } = req.query;
  const TIMEOUT = 30000; // 30 seconds

  const deadline = Date.now() + TIMEOUT;

  while (Date.now() < deadline) {
    const newEvents = await db.getEventsSince(lastEventId);

    if (newEvents.length > 0) {
      return res.json({ events: newEvents });
    }

    await sleep(1000); // Check every second
  }

  res.json({ events: [] }); // Timeout ‚Äî client will poll again
});

// Client
async function poll(lastEventId = '0') {
  try {
    const { events } = await fetch(`/poll?lastEventId=${lastEventId}`).then(r => r.json());
    events.forEach(handleEvent);
    const newLastId = events.length > 0 ? events[events.length - 1].id : lastEventId;
    poll(newLastId); // Poll again immediately
  } catch (err) {
    setTimeout(() => poll(lastEventId), 5000); // Retry after error
  }
}
```

**Comparison:**

| Protocol | Direction | Complexity | Latency | Use Case |
|----------|-----------|------------|---------|---------|
| HTTP | Request-response | Low | Medium | APIs |
| Long Polling | Server‚ÜíClient | Medium | Medium | Simple notifications |
| SSE | Server‚ÜíClient | Low | Low | Feeds, notifications |
| WebSocket | Bidirectional | High | Very Low | Chat, gaming, collaboration |

---

## 7.5 gRPC

gRPC uses **Protocol Buffers** (protobuf) ‚Äî a binary serialization format that's faster and smaller than JSON.

```protobuf
// user.proto
syntax = "proto3";

service UserService {
  rpc GetUser (GetUserRequest) returns (User);
  rpc CreateUser (CreateUserRequest) returns (User);
  rpc ListUsers (ListUsersRequest) returns (stream User); // streaming!
}

message User {
  string id = 1;
  string name = 2;
  string email = 3;
}

message GetUserRequest { string id = 1; }
message CreateUserRequest { string name = 1; string email = 2; }
message ListUsersRequest { int32 page = 1; int32 limit = 2; }
```

```js
// Server
const grpc = require('@grpc/grpc-js');
const protoLoader = require('@grpc/proto-loader');

const packageDef = protoLoader.loadSync('./user.proto');
const proto = grpc.loadPackageDefinition(packageDef);

const server = new grpc.Server();
server.addService(proto.UserService.service, {
  getUser: async (call, callback) => {
    const user = await db.findUser(call.request.id);
    callback(null, user);
  }
});

server.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => {
  server.start();
});
```

**When to use gRPC:** Microservice-to-microservice communication where performance matters. Not for browser clients (needs a proxy layer like grpc-web).

---

# 8. Express.js Basic to Advanced

## 8.1 Express Setup

```js
const express = require('express');
const app = express();

// Parse JSON bodies
app.use(express.json());

// Parse URL-encoded bodies (forms)
app.use(express.urlencoded({ extended: true }));

// Serve static files
app.use(express.static('public'));

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

## 8.2 Routing

```js
// Basic routes
app.get('/health', (req, res) => {
  res.json({ status: 'ok', uptime: process.uptime() });
});

app.post('/users', createUserHandler);
app.put('/users/:id', updateUserHandler);
app.patch('/users/:id', partialUpdateHandler);
app.delete('/users/:id', deleteUserHandler);

// Route parameters
app.get('/users/:userId/orders/:orderId', (req, res) => {
  const { userId, orderId } = req.params; // strings
  res.json({ userId, orderId });
});

// Query parameters
app.get('/products', (req, res) => {
  const {
    page = '1',
    limit = '10',
    category,
    minPrice,
    maxPrice,
    sort = 'createdAt',
    order = 'desc',
    search
  } = req.query;

  // Always parse numbers from query strings
  const pageNum = parseInt(page);
  const limitNum = Math.min(parseInt(limit), 100); // cap at 100

  res.json({ pageNum, limitNum, category, search });
});

// Router ‚Äî organize routes by feature
const userRouter = express.Router();

userRouter.get('/', getUsers);
userRouter.post('/', createUser);
userRouter.get('/:id', getUser);
userRouter.put('/:id', updateUser);
userRouter.delete('/:id', deleteUser);

// Nested routes
userRouter.get('/:userId/orders', getUserOrders);

// Mount router
app.use('/api/v1/users', userRouter);
// GET /api/v1/users ‚Üí getUsers
// GET /api/v1/users/123 ‚Üí getUser
// GET /api/v1/users/123/orders ‚Üí getUserOrders
```

## 8.3 Request Object

```js
app.post('/orders', (req, res) => {
  // Body (POST/PUT/PATCH)
  const { items, paymentMethod } = req.body;

  // URL parameters (/orders/:id)
  const { id } = req.params;

  // Query string (/orders?status=pending&page=2)
  const { status, page } = req.query;

  // Headers
  const token = req.headers.authorization?.replace('Bearer ', '');
  const userAgent = req.headers['user-agent'];
  const contentType = req.headers['content-type'];

  // Cookies
  const sessionId = req.cookies?.sessionId;

  // Request info
  const ip = req.ip;           // Client IP
  const method = req.method;   // GET, POST, etc.
  const url = req.url;         // /orders?status=pending
  const path = req.path;       // /orders
  const protocol = req.protocol; // http or https
  const host = req.hostname;   // api.myapp.com
});
```

## 8.4 Response Object

```js
app.get('/demo', (req, res) => {
  // Status + JSON
  res.status(200).json({ message: 'success' });
  res.status(201).json(newResource); // Created
  res.status(204).send();            // No content (DELETE)

  // Send different content types
  res.send('Hello text');
  res.sendFile('/path/to/file.pdf');
  res.download('/path/to/file.pdf', 'invoice.pdf'); // triggers browser download

  // Redirect
  res.redirect(301, '/new-url'); // permanent
  res.redirect(302, '/login');   // temporary

  // Set headers
  res.set('X-Custom-Header', 'value');
  res.set('Cache-Control', 'max-age=3600');

  // Set cookie
  res.cookie('sessionId', 'abc123', {
    httpOnly: true,    // Not accessible via JS (XSS protection)
    secure: true,      // HTTPS only
    sameSite: 'strict', // CSRF protection
    maxAge: 7 * 24 * 60 * 60 * 1000 // 1 week in ms
  });

  // Clear cookie
  res.clearCookie('sessionId');
});
```

---

# 9. ORMs (Prisma)

## 9.1 What is an ORM?

An ORM (Object-Relational Mapper) lets you interact with your database using your programming language instead of raw SQL.

**Prisma** is the most popular modern ORM for Node.js/TypeScript.

## 9.2 Prisma Setup

```bash
npm install prisma @prisma/client
npx prisma init  # Creates prisma/schema.prisma and .env
```

## 9.3 Prisma Schema

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  password  String
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  orders    Order[]
  profile   Profile?  // one-to-one (optional)

  @@index([email])
  @@map("users") // actual table name
}

enum Role {
  USER
  ADMIN
  MODERATOR
}

model Profile {
  id     String  @id @default(cuid())
  bio    String?
  avatar String?
  userId String  @unique  // FK for one-to-one
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Product {
  id          String     @id @default(cuid())
  name        String
  description String?
  price       Decimal    @db.Decimal(10, 2)
  stock       Int        @default(0)
  category    String
  createdAt   DateTime   @default(now())

  orderItems  OrderItem[]

  @@index([category])
}

model Order {
  id        String      @id @default(cuid())
  userId    String
  user      User        @relation(fields: [userId], references: [id])
  status    OrderStatus @default(PENDING)
  total     Decimal     @db.Decimal(10, 2)
  createdAt DateTime    @default(now())

  items     OrderItem[]
}

enum OrderStatus {
  PENDING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
}

model OrderItem {
  id        String  @id @default(cuid())
  orderId   String
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId String
  product   Product @relation(fields: [productId], references: [id])
  quantity  Int
  unitPrice Decimal @db.Decimal(10, 2)
}
```

```bash
# Generate Prisma client from schema
npx prisma generate

# Create and apply migration
npx prisma migrate dev --name add-users-table

# Push schema without migration (for prototyping)
npx prisma db push

# Open Prisma Studio ‚Äî visual DB browser
npx prisma studio
```

## 9.4 CRUD with Prisma

```ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// CREATE
const user = await prisma.user.create({
  data: {
    email: 'alice@example.com',
    name: 'Alice',
    password: hashedPassword,
    profile: {
      create: {        // create related profile in same query
        bio: 'Software Engineer',
      }
    }
  },
  include: { profile: true } // return profile with user
});

// FIND
const user = await prisma.user.findUnique({
  where: { email: 'alice@example.com' },
  include: {
    profile: true,
    orders: {
      where: { status: 'DELIVERED' },
      orderBy: { createdAt: 'desc' },
      take: 5,
      include: { items: { include: { product: true } } }
    }
  }
});

const users = await prisma.user.findMany({
  where: {
    role: 'USER',
    createdAt: { gte: new Date('2024-01-01') },
    OR: [
      { name: { contains: 'alice', mode: 'insensitive' } },
      { email: { contains: 'alice' } }
    ]
  },
  orderBy: [
    { createdAt: 'desc' },
    { name: 'asc' }
  ],
  skip: (page - 1) * limit,
  take: limit,
  select: {        // only return specific fields
    id: true,
    name: true,
    email: true,
    createdAt: true
    // password omitted ‚Äî never return password!
  }
});

// UPDATE
const updatedUser = await prisma.user.update({
  where: { id: userId },
  data: {
    name: 'Alice Smith',
    profile: {
      upsert: {
        create: { bio: 'Updated bio' },
        update: { bio: 'Updated bio' }
      }
    }
  }
});

// Increment/connect/disconnect
await prisma.product.update({
  where: { id: productId },
  data: { stock: { decrement: quantity } }
});

// DELETE
await prisma.user.delete({ where: { id: userId } });
await prisma.user.deleteMany({
  where: { createdAt: { lt: oneYearAgo }, role: 'USER' }
});

// TRANSACTIONS
const [order, updatedProduct] = await prisma.$transaction([
  prisma.order.create({
    data: { userId, total, items: { create: items } }
  }),
  prisma.product.update({
    where: { id: productId },
    data: { stock: { decrement: quantity } }
  })
]);

// Interactive transaction (with logic)
const result = await prisma.$transaction(async (tx) => {
  const product = await tx.product.findUnique({ where: { id: productId } });
  if (product.stock < quantity) throw new Error('Insufficient stock');

  const order = await tx.order.create({ data: { ... } });
  await tx.product.update({
    where: { id: productId },
    data: { stock: { decrement: quantity } }
  });

  return order;
});
```

---

# 10. Middlewares, Routes, Status Codes, Global Catches

## 10.1 What is Middleware?

Middleware is a function that has access to `req`, `res`, and `next`. It runs between the request coming in and the response going out.

```js
// Middleware signature
function middleware(req, res, next) {
  // Do something with req or res
  next(); // Call next() to pass to next middleware/route
  // OR: res.send() to end the request
  // OR: next(error) to pass to error handler
}
```

## 10.2 Built-in and Third-Party Middlewares

```js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');
const compression = require('compression');

const app = express();

// Security headers
app.use(helmet());

// CORS
app.use(cors({
  origin: ['https://myapp.com', 'https://admin.myapp.com'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
}));

// Request logging
app.use(morgan('combined')); // Apache-style logs in production
app.use(morgan('dev'));       // Colorized output in development

// Body parsers
app.use(express.json({ limit: '10mb' })); // limit body size
app.use(express.urlencoded({ extended: true }));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // max 100 requests per window
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: 'Too many requests, please try again later' }
});
app.use('/api/', limiter);

// Compression
app.use(compression()); // gzip responses

// Request ID (for tracing)
app.use((req, res, next) => {
  req.requestId = require('crypto').randomUUID();
  res.set('X-Request-ID', req.requestId);
  next();
});
```

## 10.3 Custom Middleware

```js
// Authentication middleware
const authMiddleware = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const token = authHeader.split(' ')[1];
    const payload = jwt.verify(token, process.env.JWT_SECRET);

    req.user = await prisma.user.findUnique({ where: { id: payload.sub } });
    if (!req.user) return res.status(401).json({ error: 'User not found' });

    next();
  } catch (err) {
    if (err.name === 'TokenExpiredError') {
      return res.status(401).json({ error: 'Token expired' });
    }
    if (err.name === 'JsonWebTokenError') {
      return res.status(401).json({ error: 'Invalid token' });
    }
    next(err);
  }
};

// Authorization middleware factory
const requireRole = (...roles) => (req, res, next) => {
  if (!req.user) return res.status(401).json({ error: 'Unauthorized' });
  if (!roles.includes(req.user.role)) {
    return res.status(403).json({ error: 'Insufficient permissions' });
  }
  next();
};

// Logging middleware
const requestLogger = (req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(JSON.stringify({
      requestId: req.requestId,
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration: `${duration}ms`,
      ip: req.ip,
      userId: req.user?.id
    }));
  });
  next();
};

// Usage
app.use(requestLogger);
app.use('/api/v1', authMiddleware);
app.delete('/api/v1/users/:id', requireRole('admin'), deleteUser);
```

## 10.4 Global Error Handler

Express has a special error-handling middleware with 4 arguments: `(err, req, res, next)`.

```js
// Custom error classes
class AppError extends Error {
  constructor(message, statusCode, code) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = true; // operational = expected error we handle gracefully
  }
}

class ValidationError extends AppError {
  constructor(details) {
    super('Validation failed', 422, 'VALIDATION_ERROR');
    this.details = details;
  }
}

class NotFoundError extends AppError {
  constructor(resource) {
    super(`${resource} not found`, 404, 'NOT_FOUND');
  }
}

// Global error handler (must be registered AFTER all routes)
app.use((err, req, res, next) => {
  // Log the error
  console.error({
    requestId: req.requestId,
    error: err.message,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
  });

  // Prisma errors
  if (err.code === 'P2002') {
    return res.status(409).json({
      success: false,
      error: { code: 'DUPLICATE', message: 'Resource already exists' }
    });
  }

  if (err.code === 'P2025') {
    return res.status(404).json({
      success: false,
      error: { code: 'NOT_FOUND', message: 'Record not found' }
    });
  }

  // JWT errors
  if (err.name === 'TokenExpiredError') {
    return res.status(401).json({
      success: false,
      error: { code: 'TOKEN_EXPIRED', message: 'Token has expired' }
    });
  }

  // Operational errors (our custom errors)
  if (err.isOperational) {
    return res.status(err.statusCode).json({
      success: false,
      error: {
        code: err.code,
        message: err.message,
        details: err.details
      }
    });
  }

  // Programming errors or unknown errors
  // Don't leak internal details in production!
  res.status(500).json({
    success: false,
    error: {
      code: 'INTERNAL_ERROR',
      message: process.env.NODE_ENV === 'development'
        ? err.message
        : 'An unexpected error occurred'
    }
  });
});

// 404 handler (after all routes)
app.use((req, res) => {
  res.status(404).json({
    success: false,
    error: { code: 'NOT_FOUND', message: `Route ${req.method} ${req.path} not found` }
  });
});
```

---

# 11. Zod ‚Äî Schema Validation

## 11.1 Why Validate Input?

Never trust user input. Validation prevents:
- Database errors from wrong types
- Security vulnerabilities (SQL injection, XSS)
- Confusing error messages
- Storing corrupt data

## 11.2 Zod Basics

```ts
import { z } from 'zod';

// Define a schema
const userSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
  password: z.string().min(8).regex(/[A-Z]/, 'Must contain uppercase')
                            .regex(/[0-9]/, 'Must contain number'),
  age: z.number().int().min(18).max(120).optional(),
  role: z.enum(['user', 'admin']).default('user'),
  website: z.string().url().optional().or(z.literal('')), // optional URL
});

// Infer TypeScript type from schema ‚Äî single source of truth!
type User = z.infer<typeof userSchema>;

// Validate
const result = userSchema.safeParse(req.body);

if (!result.success) {
  return res.status(422).json({
    error: 'Validation failed',
    details: result.error.flatten().fieldErrors
    // { name: ['String must contain at least 2 characters'], email: ['Invalid email'] }
  });
}

const { name, email, password, role } = result.data; // fully typed!
```

## 11.3 Advanced Zod Schemas

```ts
// Nested objects
const addressSchema = z.object({
  street: z.string().min(1),
  city: z.string().min(1),
  country: z.string().length(2), // ISO 2-letter country code
  zipCode: z.string().regex(/^\d{5}(-\d{4})?$/) // US zip code
});

const createOrderSchema = z.object({
  userId: z.string().uuid(),
  items: z.array(z.object({
    productId: z.string().uuid(),
    quantity: z.number().int().min(1).max(1000)
  })).min(1, 'Order must have at least one item'),
  shippingAddress: addressSchema,
  couponCode: z.string().optional(),
  paymentMethod: z.enum(['credit_card', 'paypal', 'crypto'])
});

// String transformations
const querySchema = z.object({
  page: z.string().transform(Number).pipe(z.number().int().min(1)).default('1'),
  limit: z.string().transform(Number).pipe(z.number().int().min(1).max(100)).default('10'),
  search: z.string().trim().min(1).optional(),
  status: z.enum(['pending', 'active', 'inactive']).optional(),
  startDate: z.string().datetime().optional().transform(s => s ? new Date(s) : undefined)
});

// Custom validation
const passwordConfirmSchema = z.object({
  password: z.string().min(8),
  confirmPassword: z.string().min(8)
}).refine(data => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ['confirmPassword'] // field to attach error to
});

// Discriminated unions
const eventSchema = z.discriminatedUnion('type', [
  z.object({ type: z.literal('email'), to: z.string().email(), subject: z.string() }),
  z.object({ type: z.literal('sms'), phone: z.string(), message: z.string().max(160) }),
  z.object({ type: z.literal('push'), deviceToken: z.string(), title: z.string() })
]);
```

## 11.4 Zod Middleware Factory

```ts
// Reusable validation middleware
const validate = (schema: z.ZodSchema, source: 'body' | 'query' | 'params' = 'body') => {
  return (req: Request, res: Response, next: NextFunction) => {
    const result = schema.safeParse(req[source]);

    if (!result.success) {
      const errors = result.error.flatten();
      return res.status(422).json({
        success: false,
        error: {
          code: 'VALIDATION_ERROR',
          message: 'Validation failed',
          fieldErrors: errors.fieldErrors,
          formErrors: errors.formErrors
        }
      });
    }

    req[source] = result.data; // replace with parsed/transformed data
    next();
  };
};

// Usage
router.post('/users',
  validate(createUserSchema, 'body'),
  createUserHandler
);

router.get('/products',
  validate(querySchema, 'query'),
  getProductsHandler
);
```

---

# 12. MonoRepos & Turborepo

## 12.1 What is a Monorepo?

A monorepo is a single repository containing multiple related projects (apps and packages).

```
my-company/
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îú‚îÄ‚îÄ web/          ‚Üê Next.js frontend
‚îÇ   ‚îú‚îÄ‚îÄ api/          ‚Üê Express backend
‚îÇ   ‚îú‚îÄ‚îÄ admin/        ‚Üê Admin dashboard
‚îÇ   ‚îî‚îÄ‚îÄ mobile/       ‚Üê React Native app
‚îú‚îÄ‚îÄ packages/
‚îÇ   ‚îú‚îÄ‚îÄ ui/           ‚Üê Shared React components
‚îÇ   ‚îú‚îÄ‚îÄ types/        ‚Üê Shared TypeScript types
‚îÇ   ‚îú‚îÄ‚îÄ utils/        ‚Üê Shared utility functions
‚îÇ   ‚îú‚îÄ‚îÄ config/       ‚Üê Shared configs (eslint, tsconfig)
‚îÇ   ‚îî‚îÄ‚îÄ db/           ‚Üê Prisma client (shared between apps)
‚îî‚îÄ‚îÄ package.json      ‚Üê Root package.json
```

**Benefits:**
- Share code between apps easily
- One `git clone`, one PR for cross-cutting changes
- Consistent tooling and linting
- Atomic commits across apps

## 12.2 Setting up Turborepo

```bash
npx create-turbo@latest my-monorepo
cd my-monorepo
```

```json
// Root package.json (with pnpm workspaces)
{
  "name": "my-monorepo",
  "private": true,
  "scripts": {
    "build": "turbo run build",
    "dev": "turbo run dev",
    "test": "turbo run test",
    "lint": "turbo run lint"
  },
  "devDependencies": {
    "turbo": "latest"
  },
  "packageManager": "pnpm@8.0.0"
}
```

```yaml
# pnpm-workspace.yaml
packages:
  - "apps/*"
  - "packages/*"
```

```json
// turbo.json ‚Äî defines the task pipeline
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],  // ^ means: build all dependencies first
      "outputs": [".next/**", "dist/**"]
    },
    "dev": {
      "cache": false,           // don't cache dev servers
      "persistent": true        // long-running task
    },
    "test": {
      "dependsOn": ["build"]
    },
    "lint": {}
  }
}
```

## 12.3 Shared Packages

```json
// packages/types/package.json
{
  "name": "@myapp/types",
  "version": "0.0.1",
  "main": "./src/index.ts",
  "types": "./src/index.ts"
}
```

```ts
// packages/types/src/index.ts
export interface User {
  id: string;
  name: string;
  email: string;
  role: 'user' | 'admin';
}

export interface ApiResponse<T> {
  data: T;
  success: boolean;
  message: string;
}

export type CreateUserDto = Pick<User, 'name' | 'email'> & { password: string };
```

```json
// apps/api/package.json ‚Äî reference the shared package
{
  "dependencies": {
    "@myapp/types": "*"
  }
}
```

```ts
// apps/api/src/routes/users.ts
import { User, ApiResponse, CreateUserDto } from '@myapp/types';

app.get('/users/:id', async (req, res: Response<ApiResponse<User>>) => {
  const user = await getUser(req.params.id);
  res.json({ data: user, success: true, message: 'OK' });
});
```

```ts
// apps/web/src/api/users.ts ‚Äî same types on frontend!
import { User, ApiResponse } from '@myapp/types';

async function fetchUser(id: string): Promise<User> {
  const res = await fetch(`/api/users/${id}`);
  const json: ApiResponse<User> = await res.json();
  return json.data;
}
```

---

# 13. Serverless Backends

## 13.1 What is Serverless?

Serverless (FaaS ‚Äî Function as a Service) means you write individual functions instead of managing a server. The cloud provider handles scaling, availability, and infrastructure.

```
Traditional Server:
  Server always running ‚Üí Always paying ‚Üí You manage scaling

Serverless:
  Function sleeps ‚Üí Request arrives ‚Üí Function wakes (cold start) ‚Üí Executes ‚Üí Sleeps again
  Pay per execution, scales automatically to millions
```

**Use cases:**
- Event handlers (image uploaded ‚Üí resize)
- Cron jobs
- Webhooks
- Low-traffic APIs
- Background processing

**Not ideal for:**
- Persistent WebSocket connections
- Long-running tasks (>15 minutes)
- Latency-sensitive apps with cold start concerns

## 13.2 AWS Lambda

```js
// handler.js ‚Äî Lambda function
exports.handler = async (event, context) => {
  // event = HTTP request (via API Gateway)
  // context = Lambda runtime info

  const { httpMethod, path, body, queryStringParameters, headers } = event;

  try {
    if (httpMethod === 'GET' && path === '/users') {
      const users = await db.getUsers();
      return {
        statusCode: 200,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(users)
      };
    }

    if (httpMethod === 'POST' && path === '/users') {
      const data = JSON.parse(body);
      const user = await db.createUser(data);
      return {
        statusCode: 201,
        body: JSON.stringify(user)
      };
    }

    return { statusCode: 404, body: 'Not found' };
  } catch (err) {
    return { statusCode: 500, body: JSON.stringify({ error: err.message }) };
  }
};
```

## 13.3 Cloudflare Workers

Workers run at the edge (close to users) with virtually no cold starts.

```js
// Cloudflare Worker ‚Äî tiny, fast, runs at edge
addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
  const url = new URL(request.url);

  if (url.pathname === '/api/hello') {
    return new Response(JSON.stringify({ message: 'Hello from the edge!' }), {
      headers: { 'Content-Type': 'application/json' }
    });
  }

  // Workers KV ‚Äî key-value storage at edge
  const cached = await MY_KV.get('users');
  if (cached) {
    return new Response(cached, { headers: { 'Content-Type': 'application/json' } });
  }

  const users = await fetchUsersFromOrigin();
  await MY_KV.put('users', JSON.stringify(users), { expirationTtl: 300 }); // cache 5 min
  return new Response(JSON.stringify(users), { headers: { 'Content-Type': 'application/json' } });
}
```

## 13.4 Vercel Serverless Functions

```ts
// api/users.ts ‚Äî Vercel serverless function
import { VercelRequest, VercelResponse } from '@vercel/node';

export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (req.method === 'GET') {
    const users = await db.getUsers();
    return res.json(users);
  }

  if (req.method === 'POST') {
    const user = await db.createUser(req.body);
    return res.status(201).json(user);
  }

  res.status(405).json({ error: 'Method not allowed' });
}
```

---

# 14. OpenAPI Spec

## 14.1 What is OpenAPI?

OpenAPI (formerly Swagger) is a standard for describing REST APIs in a machine-readable format (YAML/JSON). It enables:

- Auto-generated interactive documentation
- Auto-generated client SDKs
- API validation
- API testing
- Contract-first development

## 14.2 Writing OpenAPI Spec

```yaml
# openapi.yaml
openapi: "3.0.3"
info:
  title: MyApp API
  version: "1.0.0"
  description: |
    Complete API documentation for MyApp.
    All endpoints require authentication unless marked as public.
  contact:
    name: API Support
    email: api@myapp.com

servers:
  - url: https://api.myapp.com/v1
    description: Production
  - url: http://localhost:3000/api/v1
    description: Development

# Reusable components
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

  schemas:
    User:
      type: object
      required: [id, name, email, role, createdAt]
      properties:
        id:
          type: string
          format: uuid
          example: "550e8400-e29b-41d4-a716-446655440000"
        name:
          type: string
          minLength: 2
          maxLength: 100
          example: "Alice Smith"
        email:
          type: string
          format: email
          example: "alice@example.com"
        role:
          type: string
          enum: [user, admin]
        createdAt:
          type: string
          format: date-time

    CreateUserRequest:
      type: object
      required: [name, email, password]
      properties:
        name:
          type: string
          minLength: 2
        email:
          type: string
          format: email
        password:
          type: string
          minLength: 8

    Error:
      type: object
      properties:
        success:
          type: boolean
          example: false
        error:
          type: object
          properties:
            code:
              type: string
            message:
              type: string

    Pagination:
      type: object
      properties:
        page:
          type: integer
        limit:
          type: integer
        total:
          type: integer
        totalPages:
          type: integer

# Apply auth globally (can override per route)
security:
  - bearerAuth: []

paths:
  /users:
    get:
      summary: List users
      operationId: listUsers
      tags: [Users]
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: limit
          in: query
          schema:
            type: integer
            default: 10
            maximum: 100
        - name: search
          in: query
          schema:
            type: string
      responses:
        "200":
          description: List of users
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: "#/components/schemas/User"
                  pagination:
                    $ref: "#/components/schemas/Pagination"
        "401":
          description: Unauthorized
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error"

    post:
      summary: Create a user
      operationId: createUser
      tags: [Users]
      security: []  # Override: this endpoint is public
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/CreateUserRequest"
      responses:
        "201":
          description: User created
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/User"
        "422":
          description: Validation error

  /users/{id}:
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: string
          format: uuid

    get:
      summary: Get user by ID
      operationId: getUser
      tags: [Users]
      responses:
        "200":
          description: User found
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/User"
        "404":
          description: User not found
```

## 14.3 Auto-generating OpenAPI from Code

```ts
// Using tsoa ‚Äî generates OpenAPI from TypeScript decorators
import { Route, Controller, Get, Post, Body, Path, Query, Security } from 'tsoa';

@Route('users')
@Security('bearerAuth')
export class UserController extends Controller {

  @Get('/')
  async listUsers(
    @Query() page: number = 1,
    @Query() limit: number = 10,
    @Query() search?: string
  ): Promise<{ data: User[]; pagination: Pagination }> {
    return userService.findMany({ page, limit, search });
  }

  @Post('/')
  async createUser(@Body() body: CreateUserRequest): Promise<User> {
    this.setStatus(201);
    return userService.create(body);
  }

  @Get('{id}')
  async getUser(@Path() id: string): Promise<User> {
    return userService.findById(id);
  }
}

// tsoa generates openapi.yaml and routes automatically
// npx tsoa spec-and-routes
```

---

# 15. Autogenerated Clients

## 15.1 Why Autogenerate?

Manually writing API fetch functions is tedious and error-prone. When the API changes, you update the OpenAPI spec and regenerate the client ‚Äî no manual sync needed.

## 15.2 Using orval

```bash
npm install -D orval
```

```ts
// orval.config.ts
import { defineConfig } from 'orval';

export default defineConfig({
  myApi: {
    input: './openapi.yaml',
    output: {
      mode: 'tags-split', // split by tags (Users, Products, etc.)
      target: './src/api',
      client: 'react-query', // or 'axios', 'fetch', 'swr'
      schemas: './src/api/model',
      prettier: true
    }
  }
});
```

```bash
npx orval --config orval.config.ts
```

Generated code:
```ts
// src/api/users.ts (autogenerated ‚Äî don't edit!)
export const listUsers = (params?: ListUsersParams) => {
  return axios.get<{ data: User[]; pagination: Pagination }>(`/users`, { params });
};

export const createUser = (createUserRequest: CreateUserRequest) => {
  return axios.post<User>(`/users`, createUserRequest);
};

export const getUser = (id: string) => {
  return axios.get<User>(`/users/${id}`);
};

// React Query hooks (if using react-query mode)
export const useListUsers = (params?: ListUsersParams, options?: UseQueryOptions) => {
  return useQuery(['users', params], () => listUsers(params), options);
};

export const useCreateUser = (options?: UseMutationOptions) => {
  return useMutation((data: CreateUserRequest) => createUser(data), options);
};
```

---

# 16. Authentication using External Libraries

## 16.1 Authentication Concepts

**Authentication:** Who are you? (login)
**Authorization:** What can you do? (permissions)

**Session-based auth:**
```
1. User logs in ‚Üí Server creates session, stores in DB
2. Server sends session cookie to client
3. Client sends cookie with every request
4. Server looks up session in DB to authenticate
```

**JWT-based auth:**
```
1. User logs in ‚Üí Server creates JWT (signed with secret)
2. Server sends JWT to client (stored in memory or cookie)
3. Client sends JWT in Authorization header
4. Server verifies JWT signature ‚Äî no DB lookup needed!
```

## 16.2 JWT from Scratch

```ts
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';

const JWT_SECRET = process.env.JWT_SECRET!;
const JWT_EXPIRES_IN = '15m';
const REFRESH_EXPIRES_IN = '7d';

// Hash password
async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, 12); // 12 rounds is the sweet spot
}

// Verify password
async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

// Generate tokens
function generateTokens(userId: string, role: string) {
  const accessToken = jwt.sign(
    { sub: userId, role, type: 'access' },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES_IN }
  );

  const refreshToken = jwt.sign(
    { sub: userId, type: 'refresh' },
    JWT_SECRET,
    { expiresIn: REFRESH_EXPIRES_IN }
  );

  return { accessToken, refreshToken };
}

// Login route
app.post('/auth/login', async (req, res) => {
  const { email, password } = req.body;

  const user = await prisma.user.findUnique({ where: { email } });
  if (!user) return res.status(401).json({ error: 'Invalid credentials' });

  const valid = await verifyPassword(password, user.password);
  if (!valid) return res.status(401).json({ error: 'Invalid credentials' });

  const { accessToken, refreshToken } = generateTokens(user.id, user.role);

  // Store refresh token in DB (for revocation)
  await prisma.refreshToken.create({
    data: {
      token: refreshToken,
      userId: user.id,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    }
  });

  // Send refresh token as httpOnly cookie (more secure than localStorage)
  res.cookie('refreshToken', refreshToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000
  });

  res.json({ accessToken, user: { id: user.id, name: user.name, role: user.role } });
});

// Refresh token route
app.post('/auth/refresh', async (req, res) => {
  const refreshToken = req.cookies.refreshToken;
  if (!refreshToken) return res.status(401).json({ error: 'No refresh token' });

  const payload = jwt.verify(refreshToken, JWT_SECRET) as { sub: string };

  // Check if token exists in DB (not revoked)
  const storedToken = await prisma.refreshToken.findFirst({
    where: { token: refreshToken, userId: payload.sub }
  });
  if (!storedToken) return res.status(401).json({ error: 'Invalid refresh token' });

  const user = await prisma.user.findUnique({ where: { id: payload.sub } });
  const { accessToken, refreshToken: newRefreshToken } = generateTokens(user.id, user.role);

  // Rotate refresh token
  await prisma.refreshToken.update({
    where: { id: storedToken.id },
    data: { token: newRefreshToken }
  });

  res.cookie('refreshToken', newRefreshToken, { httpOnly: true, secure: true });
  res.json({ accessToken });
});
```

## 16.3 OAuth2 with Passport.js

```ts
import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';

passport.use(new GoogleStrategy({
  clientID: process.env.GOOGLE_CLIENT_ID!,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
  callbackURL: '/auth/google/callback'
}, async (accessToken, refreshToken, profile, done) => {
  try {
    // Find or create user
    let user = await prisma.user.findUnique({
      where: { googleId: profile.id }
    });

    if (!user) {
      user = await prisma.user.create({
        data: {
          googleId: profile.id,
          email: profile.emails![0].value,
          name: profile.displayName,
          avatar: profile.photos![0].value,
          role: 'USER'
        }
      });
    }

    done(null, user);
  } catch (err) {
    done(err, null);
  }
}));

app.use(passport.initialize());

app.get('/auth/google',
  passport.authenticate('google', { scope: ['profile', 'email'], session: false })
);

app.get('/auth/google/callback',
  passport.authenticate('google', { session: false, failureRedirect: '/login' }),
  (req, res) => {
    const { accessToken } = generateTokens(req.user.id, req.user.role);
    // Redirect to frontend with token
    res.redirect(`${process.env.FRONTEND_URL}/auth/callback?token=${accessToken}`);
  }
);
```

---

# 17. Scaling Node.js & Performance Benchmarks

## 17.1 Understanding Node.js Scaling

Node.js is single-threaded. By default, it uses one CPU core. To scale:

1. **Vertical scaling** ‚Äî bigger machine
2. **Horizontal scaling** ‚Äî more machines (with load balancer)
3. **Cluster module** ‚Äî use all CPU cores on one machine

## 17.2 Cluster Module

```js
const cluster = require('cluster');
const os = require('os');
const express = require('express');

if (cluster.isPrimary) {
  const numCPUs = os.cpus().length;
  console.log(`Primary ${process.pid}: Forking ${numCPUs} workers`);

  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code) => {
    console.log(`Worker ${worker.process.pid} died. Forking new one.`);
    cluster.fork(); // Restart dead worker
  });
} else {
  // Worker process
  const app = express();

  app.get('/health', (req, res) => {
    res.json({ pid: process.pid, status: 'ok' });
  });

  app.listen(3000, () => {
    console.log(`Worker ${process.pid} started`);
  });
}
```

## 17.3 Worker Threads

For CPU-intensive tasks (video processing, image resizing, complex calculations):

```js
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');

if (isMainThread) {
  // Main thread ‚Äî don't block here!
  app.post('/process-image', async (req, res) => {
    const result = await new Promise((resolve, reject) => {
      const worker = new Worker('./imageProcessor.js', {
        workerData: { imageBuffer: req.body, options: req.query }
      });

      worker.on('message', resolve);
      worker.on('error', reject);
    });

    res.json(result);
  });
} else {
  // Worker thread ‚Äî runs in separate thread, won't block event loop
  const { imageBuffer, options } = workerData;
  const processed = heavyImageProcessing(imageBuffer, options); // OK to block here
  parentPort.postMessage(processed);
}
```

## 17.4 Caching with Redis

```ts
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

// Cache middleware
function cache(ttlSeconds: number) {
  return async (req: Request, res: Response, next: NextFunction) => {
    const key = `cache:${req.method}:${req.url}`;

    const cached = await redis.get(key);
    if (cached) {
      res.set('X-Cache', 'HIT');
      return res.json(JSON.parse(cached));
    }

    // Override res.json to cache the response
    const originalJson = res.json.bind(res);
    res.json = (body) => {
      redis.setex(key, ttlSeconds, JSON.stringify(body));
      res.set('X-Cache', 'MISS');
      return originalJson(body);
    };

    next();
  };
}

// Cache product listings for 5 minutes
app.get('/products', cache(300), getProductsHandler);

// Cache user profile for 60 seconds
app.get('/users/:id', cache(60), getUserHandler);

// Invalidate cache on update
app.put('/products/:id', async (req, res) => {
  await updateProduct(req.params.id, req.body);

  // Clear relevant caches
  const keys = await redis.keys('cache:GET:/products*');
  if (keys.length) await redis.del(...keys);

  res.json({ success: true });
});
```

## 17.5 Performance Benchmarking

```bash
# Install autocannon
npm install -g autocannon

# Basic benchmark
autocannon -c 100 -d 30 http://localhost:3000/api/users
# -c 100 = 100 concurrent connections
# -d 30 = 30 seconds

# With custom headers
autocannon -c 50 -d 10 \
  -H "Authorization: Bearer eyJhbGci..." \
  http://localhost:3000/api/protected

# POST request
autocannon -c 100 -d 10 \
  -m POST \
  -H "Content-Type: application/json" \
  -b '{"name":"Alice","email":"alice@test.com"}' \
  http://localhost:3000/api/users
```

```
Stat    2.5% 50% 97.5% 99%   Avg      Stdev  Max
Latency 3ms  5ms 19ms  36ms  5.4ms    4.5ms  143ms

Req/Bytes counts sampled once per second.
# of samples: 30

200k requests in 30.02s, 45.2 MB read
Requests/sec: 6,661
Latency: 5.4ms average
```

---

# 18. Deploying npm Packages

## 18.1 Package Structure

```
my-package/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ index.ts        ‚Üê Source code
‚îú‚îÄ‚îÄ dist/               ‚Üê Compiled output (gitignored)
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ index.d.ts      ‚Üê Type definitions
‚îÇ   ‚îî‚îÄ‚îÄ index.js.map    ‚Üê Source maps
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ .npmignore          ‚Üê What to exclude from published package
```

## 18.2 package.json for Publishing

```json
{
  "name": "@myorg/my-package",    // scoped package
  "version": "1.0.0",
  "description": "A useful package",
  "main": "./dist/index.js",       // CJS entry point
  "module": "./dist/index.mjs",    // ESM entry point
  "types": "./dist/index.d.ts",    // TypeScript types
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "files": ["dist", "README.md"],  // Only publish these files
  "scripts": {
    "build": "tsup src/index.ts --format cjs,esm --dts",
    "prepublishOnly": "npm run build && npm test"
  },
  "keywords": ["utility", "node"],
  "license": "MIT",
  "peerDependencies": {
    "react": ">=18.0.0"            // peer deps not auto-installed
  }
}
```

## 18.3 Publishing

```bash
# Login to npm
npm login

# For scoped packages ‚Äî set registry access to public
npm publish --access public

# Update version (semver)
npm version patch  # 1.0.0 ‚Üí 1.0.1 (bug fix)
npm version minor  # 1.0.0 ‚Üí 1.1.0 (new feature, backward compatible)
npm version major  # 1.0.0 ‚Üí 2.0.0 (breaking change)

# Publish beta
npm version 2.0.0-beta.1
npm publish --tag beta
# Users install with: npm install @myorg/my-package@beta
```

## 18.4 Automated Releases with GitHub Actions

```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    tags:
      - 'v*'  # Trigger on version tags (v1.0.0, v1.2.3)

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - run: npm ci
      - run: npm test
      - run: npm run build

      - name: Publish to npm
        run: npm publish --access public
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

**Semantic versioning (semver):**

```
MAJOR.MINOR.PATCH
  ‚îÇ      ‚îÇ     ‚îî‚îÄ‚îÄ Bug fixes (backward compatible)
  ‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ New features (backward compatible)
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Breaking changes

1.0.0 ‚Üí Initial release
1.0.1 ‚Üí Bug fix
1.1.0 ‚Üí New feature added
2.0.0 ‚Üí Breaking API change
```

---

# Quick Reference ‚Äî Status Codes Cheat Sheet

| Code | Name | When to Use |
|------|------|-------------|
| 200 | OK | Successful GET, PUT, PATCH |
| 201 | Created | Successful POST that creates a resource |
| 204 | No Content | Successful DELETE, or update with no body |
| 301 | Moved Permanently | URL has changed permanently |
| 304 | Not Modified | Client cache is still valid |
| 400 | Bad Request | Malformed request, wrong Content-Type |
| 401 | Unauthorized | Not authenticated (no/invalid token) |
| 403 | Forbidden | Authenticated but lacks permission |
| 404 | Not Found | Resource doesn't exist |
| 409 | Conflict | Duplicate resource (email exists) |
| 422 | Unprocessable Entity | Validation failed |
| 429 | Too Many Requests | Rate limit hit |
| 500 | Internal Server Error | Unexpected error |
| 503 | Service Unavailable | Server temporarily down |

---